# -*- coding: utf-8 -*-
"""Listo para Flask

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JxPoUxVKBCa-Io60W6GEDs22vWUpoWbk
"""

import math
import requests
import json
import pandas as pd
import datetime
import numpy as np

from simulated_functions_find_combinations import *

normalized_city_score = [['london', 1.0, 'United Kingdom'],
 ['rome', 1.0, 'Italy'],
 ['naples', 1.0, 'Italy'],
 ['malaga', 1.0, 'Spain'],
 ['alicante', 1.0, 'Spain'],
 ['amsterdam', 1.0, 'Netherlands'],
 ['stockholm', 1.0, 'Sweden'],
 ['barcelona', 1.0, 'Spain'],
 ['berlin', 1.0, 'Germany'],
 ['madrid', 1.0, 'Spain'],
 ['milan', 1.0, 'Italy'],
 ['venice', 1.0, 'Italy'],
 ['brussels', 1.0, 'Belgium'],
 ['manchester', 1.0, 'United Kingdom'],
 ['budapest', 1.0, 'Hungary'],
 ['palma', 1.0, 'Spain'],
 ['copenhagen', 1.0, 'Denmark'],
 ['paris', 1.0, 'France'],
 ['porto', 1.0, 'Portugal'],
 ['dublin', 1.0, 'Ireland'],
 ['sofia', 0.9629629629629629, 'Bulgaria'],
 ['liverpool', 0.9629629629629629, 'United Kingdom'],
 ['wroclaw', 0.9259259259259259, 'Poland'],
 ['prague', 0.9259259259259259, 'Czechia'],
 ['seville', 0.9259259259259259, 'Spain'],
 ['athens', 0.9259259259259259, 'Greece'],
 ['lisbon', 0.9259259259259259, 'Portugal'],
 ['valencia', 0.8888888888888888, 'Spain'],
 ['barcelona', 0.8888888888888888, 'Spain'],
 ['helsinki', 0.8518518518518519, 'Finland'],
 ['ibiza', 0.8148148148148148, 'Spain'],
 ['vilnius', 0.8148148148148148, 'Lithuania'],
 ['marrakech', 0.8148148148148148, 'Morocco'],
 ['oslo', 0.8148148148148148, 'Norway'],
 ['belfast', 0.8148148148148148, 'United Kingdom'],
 ['lanzarote', 0.7777777777777778, 'Spain'],
 ['las-palmas', 0.7777777777777778, 'Spain'],
 ['munich', 0.7777777777777778, 'Germany'],
 ['zurich', 0.7407407407407407, 'Switzerland'],
 ['salzburg', 0.7407407407407407, 'Austria'],
 ['vienna', 0.7037037037037037, 'Austria'],
 ['bratislava', 0.7037037037037037, 'Slovakia'],
 ['riga', 0.7037037037037037, 'Latvia'],
 ['bilbao', 0.7037037037037037, 'Spain'],
 ['mikonos', 0.5925925925925926, 'Greece'],
 ['santander', 0.5925925925925926, 'Spain'],
 ['dubrovnik', 0.5555555555555556, 'Croatia'],
 ['fuerteventura', 0.5555555555555556, 'Spain'],
 ['santiago-de-compostela', 0.5555555555555556, 'Spain'],
 ['mahon', 0.5185185185185185, 'United States'],
 ['asturias', 0.48148148148148145, 'Spain'],
 ['granada', 0.4074074074074074, 'Spain'],
 ['almeria', 0.37037037037037035, 'Spain'],
 ['tenerife', 0.3333333333333333, 'Spain'],
 ['santa-cruz-de-la-palma', 0.2962962962962963, 'Spain'],
 ['murcia', 0.2962962962962963, 'Spain'],
 ['vigo', 0.2962962962962963, 'Spain'],
 ['zaragoza', 0.2962962962962963, 'Spain'],
 ['jerez', 0.25925925925925924, 'Spain']]

df_normalized_city_score = pd.DataFrame(normalized_city_score,columns=["city","score", "country"])



# Función que suma días
def addDays(fecha,days):
  fecha = datetime.datetime.strptime(fecha, "%d/%m/%Y")
  fecha2 = fecha + datetime.timedelta(days=int(days))
  return datetime.datetime.strftime(fecha2, "%d/%m/%Y")


# Convertir todos los vuelos del DF de una combinación a una única fila
def compressFlightsToCombination(combinations_flights):
  #one_combination_flights = pd.DataFrame([],  columns = full_matrix.columns.values)
  compressed_combination = combinations_flights.loc[0].copy()
  string_columns = ["To", "Hour", "Date", "Id"]
  for column in string_columns:
    compressed_combination[column] = combinations_flights[column].tolist()
  compressed_combination["Id"] = str(compressed_combination["Id"])[1:-1].replace("'","").replace(", ","%7C")
  compressed_combination["Price"] = np.sum(combinations_flights['Price'].values)
  route_columns = ['From', 'To', 'Date', 'Hour', 'Price']
  compressed_combination["Route"] = (combinations_flights[route_columns].
                                     values.tolist())
  return compressed_combination


# Convertir un DF te combinaciones al formato diccionario
def convertCombinationDfToDict(combinations_df, passengers):
  combination_dict = {}
  for index, combination in combinations_df.iterrows():
    price_by_person = round(float(combination['Price'])/passengers,2)
    combination_dict["combination{}".format(index)] = {
        'passengers': passengers,
        'departure': combination['From'], 
        'destinations': combination['To'],
        'dates': combination['Date'],
        'price': price_by_person,
        'url': ("https://www.kiwi.com/deep?flightsId={}&price={}&passengers={}&affilid=picky&lang=es&currency=EUR".
                format(combination['Id'],combination['Price'],passengers)),
        'route': combination['Route']
    }
  return combination_dict

 
# Función para encontrar el mejor trayecto utilizando el algoritmo meta-heurístico
def findBestPathLocMulti(full_matrix, departure_cities, ciudades_deseadas, n_ciudades_a_visitar, fechas, pasajeros, n_combinaciones):
  n_viajes = n_ciudades_a_visitar + 1
  n_ciudades_a_elegir = len(ciudades_deseadas) #conjunto ciudades entre las que elegir
  
  # comprobar que sea posible elegir n combinaciones con tantas ciudades y tantos viajes
  possible_combinations = int(math.factorial(n_ciudades_a_elegir)/math.factorial(n_ciudades_a_elegir - n_ciudades_a_visitar))
  if (n_combinaciones > possible_combinations):
    # it is not posible to find all the combinations in these conditions
    print("Not possible to create {} combinations by choosing {} of {} desired cities! Only {} are possible"
                     .format(n_combinaciones, n_ciudades_a_visitar, n_ciudades_a_elegir, possible_combinations))
    n_combinaciones = possible_combinations
  
  # buscamos el mejor recorrido para cada una de las combinaciones
  print("Show {} combinations from all the {}: choose {} cities from {} choices ({} flights)"
        .format(n_combinaciones, possible_combinations, n_ciudades_a_visitar, n_ciudades_a_elegir, n_viajes))
  all_combinations_flights = pd.DataFrame([], columns =  np.append(full_matrix.columns.values, "Route"))
  all_paths = {}
  combination = 0
  comb_found = 0
  print("Departure and arrival unique cities: ", departure_cities)
  while (comb_found < n_combinaciones) and (combination < possible_combinations):
    print("*****************************************************************")
    one_combination_flights = pd.DataFrame([], columns = full_matrix.columns.values)
    visited_cities = departure_cities.copy()
    current_city = departure_cities.copy()

    # calcula el idx_viaje para el que habrá que hacer excepcion y no elegir el viaje mas barato para generar combinaciones
    flight_to_except = (combination - 1)%(n_ciudades_a_visitar)
    index_if_except = math.ceil(float(combination)/(n_ciudades_a_visitar))
    print('In combination {} we must choose the {} cheaper price for flight {}'
          .format(combination + 1, index_if_except + 1, flight_to_except + 1))

    # calcula los precios desde la ciudad actual hasta las siguientes
    discard_comb = False
    for idx_viaje in range(n_viajes):
      current_date = fechas[idx_viaje]
      print('Starting flight {}/{}: from {} on date {}'.format(idx_viaje + 1,n_viajes,current_city, current_date))
      
      # Mira si el viaje actual es el último o no
      if (idx_viaje + 1) < n_viajes:
        # Si no es el último viaje, además hay que evitar que el destino sea una ciudad ya visitada
        accepted_cities = [element not in visited_cities for element in full_matrix['To']]     
      else:
        # Si es el último viaje, destino tiene que ser un de las ciudades de origen
        accepted_cities = [element in departure_cities for element in full_matrix['To']]
      
      # Mirar destinos posibles teniendo en cuenta lo anterior, la fecha y la ciudad actual
      filas_viajes_posibles = ([element in current_city for element in full_matrix['From']] & 
                               (full_matrix['Date'] == current_date) & accepted_cities)
      
      # Saca el df con todos los posibles destinos encontrados
      n_viajes_posibles = np.sum(filas_viajes_posibles)
      if n_viajes_posibles > 0:
        viajes_posibles = full_matrix.loc[filas_viajes_posibles].sort_values('Price')
      else:
        viajes_posibles = pd.DataFrame([], columns = full_matrix.columns.values)
        discard_comb = True
        print("No flights found from {} on {}!".format(current_city, current_date))
      print("All the flights found:\n", viajes_posibles)
      
      # Decide si este vuelo es la excepción para generar varias combinaciones y mira si hay suficientes
      if idx_viaje == flight_to_except:
        # Comprueba que se hayan encontrado encontrado alternativas suficientes
        index_lower_price = index_if_except
        if (index_if_except >= n_viajes_posibles):
          discard_comb = True
          print("Not enough flights in combination {} from {} on {} to find another combination!"
                            .format(combination + 1, current_city, current_date))
      else:
        # No es la excepcion o es el vuelo de vuelta
        index_lower_price = 0
      print('Choosen flight {} of {} possible trips:\n {}'.
            format(index_lower_price + 1, n_viajes_posibles, viajes_posibles))

      # Actualiza los datos del mejor vuelo encontrado si la comb es valida
      if not discard_comb:
        one_combination_flights.loc[idx_viaje] = viajes_posibles.iloc[index_lower_price].copy()
        current_city = one_combination_flights['To'].loc[idx_viaje]
        visited_cities.append(current_city)
      else:
        print("Combination {} was discarded".format(combination + 1))
        break
      #print("visited cities: ", visited_cities)
    # comprime la info de todos los vuelos de la combinación encontrada en una única fila
    print("For combination {} there are the following flights:\n{}".format(combination+1, one_combination_flights))
    if not discard_comb:
      all_combinations_flights.loc[comb_found] = compressFlightsToCombination(one_combination_flights)
      comb_found += 1
      print("For combination {} there are the following flights:\n{}".format(comb_found, one_combination_flights))
    combination += 1
  all_combinations_flights.drop('CodeTo', axis=1, inplace=True)
  all_combinations_flights.sort_values(["Price"], inplace=True)
  return all_combinations_flights



def getMatrixAndCombinations (origen, destinos, fecha_salida, dias_por_ciudad, numero_ciudades, pasajeros, n_combinaciones):
  """
  Esta funcion tiene como entrada los inputs del usuario. Crea la matriz de vuelos usando fullMatrix, saca los inputs necesarios
  para llamar a "findbestpathloc", y del df de combinacioneshace el return del json.
  """
  # Sacamos el DF con la info de todos los vuelos necesarios
  full_matrix = fullMatrix(origen, destinos, fecha_salida,dias_por_ciudad, numero_ciudades, pasajeros, n_combinaciones)
  print("La matriz de vuelos queda:\n", full_matrix.loc[:, full_matrix.columns != 'Id'])
  
  # Sacamos origen, destinos, fechas y número de ciudades
  fechas = sorted(full_matrix["Date"].unique().tolist())
  print("fechas:", fechas)
  origen = list(full_matrix.loc[(full_matrix["Date"] == fechas[0]), "From"].unique())
  print("origen:", origen)
  ciudades_vuelta = list(full_matrix.loc[(full_matrix["Date"] == fechas[-1]), "To"].unique())
  print("ciudades vuelta:", ciudades_vuelta)
  origen.extend(city for city in ciudades_vuelta if city not in origen)
  print("ciudades origen/vuelta", ciudades_vuelta)
  destinos = [city for city in full_matrix["To"].unique() if city != origen]
  full_matrix['Price'] = full_matrix['Price'].apply(pd.to_numeric)
  
  # De todos los vuelos encontramos las mejores combinaciones
  best_combinations_df = findBestPathLocMulti(full_matrix, origen, destinos, numero_ciudades, fechas, pasajeros, n_combinaciones)
  # Convertimos a diccionario
  #best_combinations_dict = convertCombinationDfToDict(all_combinations_flights, pasajeros))
  # Convertimos a json
  #best_combinations_json = json.dumps(best_combinations_dict, cls=MyEncoder)
  
  return best_combinations_df

origen = "madrid"
destinos_posibles = ['BCN', 'PAR', 'LON', 'BER']
fecha = "11/08/2018"
dias_por_ciudad = 2
numero_ciudades = 3
pasajeros = 2
combinaciones = 5
combinations_df = getMatrixAndCombinations (origen, destinos_posibles, fecha, dias_por_ciudad, numero_ciudades, pasajeros, combinaciones)
combinations_df

origen = "madrid"
destinos_posibles = []
fecha = "11/08/2018"
dias_por_ciudad = 2
numero_ciudades = 3
pasajeros = 2
combinaciones = 5
combinations_df = getMatrixAndCombinations (origen, destinos_posibles, fecha, dias_por_ciudad, numero_ciudades, pasajeros, combinaciones)
combinations_df

test_full_matrix = fullMatrixNoDestinos("madrid", df_normalized_city_score, "11/08/2018", 2, 3, 2)

test_full_matrix

origen = "BCN"
destinos_posibles = ["DUB", "VIE", "ATH","TLS"]
fecha = "15/07/2018"
dias_por_ciudad = 2
ciudades_minimas_visitar = 3
pasajeros = 1
combinaciones = 10
full_matrix = fullMatrix(origen, destinos_posibles, fecha, dias_por_ciudad, ciudades_minimas_visitar, pasajeros, combinaciones)
full_matrix
solucion="""
2  Barcelona  [Atenas, Toulouse, Dublín, Barcelona]   
0  Barcelona   [Toulouse, Atenas, Viena, Barcelona]   
3  Barcelona     [Dublín, Viena, Atenas, Barcelona]   
1  Barcelona  [Toulouse, Atenas, Dublín, Barcelona]   
"""

origen = "BCN"
destinos_posibles = ["LPL","DUB", "VIE", "ATH","TLS", "MPL"]
fecha = "15/08/2018"
dias_por_ciudad = 2
ciudades_minimas_visitar = 3
pasajeros = 1
combinaciones = 10
full_matrix = fullMatrix(origen, destinos_posibles, fecha, dias_por_ciudad, ciudades_minimas_visitar, pasajeros, combinaciones)
full_matrix
solucion="""
1  Barcelona  [Liverpool, Dublín, Toulouse, Barcelona]   
4  Barcelona     [Viena, Dublín, Liverpool, Barcelona]   
0  Barcelona    [Liverpool, Dublín, Atenas, Barcelona]   
3  Barcelona     [Liverpool, Dublín, Viena, Barcelona]   
2  Barcelona        [Atenas, Viena, Dublín, Barcelona]   
"""

origen = "BCN"
destinos_posibles = ["BUD","OTP", "SOF", "PRG", "ATH", "KRK", "WAW", "DBK", "BTS"]
fecha = "15/08/2018"
dias_por_ciudad = 3
ciudades_minimas_visitar = 3
pasajeros = 1
combinaciones = 4
full_matrix = fullMatrix(origen, destinos_posibles, fecha, dias_por_ciudad, ciudades_minimas_visitar, pasajeros, combinaciones)
full_matrix
solucion= """
1  Barcelona  [Praga, Varsovia, Bratislava, Gerona]   
2  Barcelona    [Sofía, Budapest, Praga, Barcelona]   
0  Barcelona   [Sofía, Atenas, Bucarest, Barcelona]   
3  Barcelona   [Sofía, Atenas, Budapest, Barcelona]
"""

origen = "BCN"
destinos_posibles = ["BUD","OTP", "SOF", "ATH", "KRK", "WAW", "DBK", "BTS"]
fecha = "15/08/2018"
dias_por_ciudad = 3
ciudades_minimas_visitar = 3
pasajeros = 1
combinaciones = 10
full_matrix = fullMatrix(origen, destinos_posibles, fecha, dias_por_ciudad, ciudades_minimas_visitar, pasajeros, combinaciones)
full_matrix
solucion="""
2  Barcelona     [Sofía, Budapest, Varsovia, Barcelona]   
0  Barcelona       [Sofía, Atenas, Bucarest, Barcelona]   
3  Barcelona       [Sofía, Atenas, Budapest, Barcelona]   
6  Barcelona        [Sofía, Atenas, Bratislava, Gerona]   
8  Barcelona       [Sofía, Atenas, Varsovia, Barcelona]   
4  Barcelona       [Budapest, Sofía, Atenas, Barcelona]   
1  Barcelona  [Varsovia, Bratislava, Atenas, Barcelona]   
7  Barcelona       [Atenas, Sofía, Budapest, Barcelona]   
9  Barcelona       [Bucarest, Atenas, Sofía, Barcelona]   
5  Barcelona      [Sofía, Varsovia, Bratislava, Gerona]   
"""
