 push # -*- coding: utf-8 -*-
"""Listo para Flask

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JxPoUxVKBCa-Io60W6GEDs22vWUpoWbk
"""

import math
import requests
import json
import pandas as pd
import datetime
import numpy as np

normalized_city_score = [['london', 1.0, 'United Kingdom'],
 ['rome', 1.0, 'Italy'],
 ['naples', 1.0, 'Italy'],
 ['malaga', 1.0, 'Spain'],
 ['alicante', 1.0, 'Spain'],
 ['amsterdam', 1.0, 'Netherlands'],
 ['stockholm', 1.0, 'Sweden'],
 ['barcelona', 1.0, 'Spain'],
 ['berlin', 1.0, 'Germany'],
 ['madrid', 1.0, 'Spain'],
 ['milan', 1.0, 'Italy'],
 ['venice', 1.0, 'Italy'],
 ['brussels', 1.0, 'Belgium'],
 ['manchester', 1.0, 'United Kingdom'],
 ['budapest', 1.0, 'Hungary'],
 ['palma', 1.0, 'Spain'],
 ['copenhagen', 1.0, 'Denmark'],
 ['paris', 1.0, 'France'],
 ['porto', 1.0, 'Portugal'],
 ['dublin', 1.0, 'Ireland'],
 ['sofia', 0.9629629629629629, 'Bulgaria'],
 ['liverpool', 0.9629629629629629, 'United Kingdom'],
 ['wroclaw', 0.9259259259259259, 'Poland'],
 ['prague', 0.9259259259259259, 'Czechia'],
 ['seville', 0.9259259259259259, 'Spain'],
 ['athens', 0.9259259259259259, 'Greece'],
 ['lisbon', 0.9259259259259259, 'Portugal'],
 ['valencia', 0.8888888888888888, 'Spain'],
 ['barcelona', 0.8888888888888888, 'Spain'],
 ['helsinki', 0.8518518518518519, 'Finland'],
 ['ibiza', 0.8148148148148148, 'Spain'],
 ['vilnius', 0.8148148148148148, 'Lithuania'],
 ['marrakech', 0.8148148148148148, 'Morocco'],
 ['oslo', 0.8148148148148148, 'Norway'],
 ['belfast', 0.8148148148148148, 'United Kingdom'],
 ['lanzarote', 0.7777777777777778, 'Spain'],
 ['las-palmas', 0.7777777777777778, 'Spain'],
 ['munich', 0.7777777777777778, 'Germany'],
 ['zurich', 0.7407407407407407, 'Switzerland'],
 ['salzburg', 0.7407407407407407, 'Austria'],
 ['vienna', 0.7037037037037037, 'Austria'],
 ['bratislava', 0.7037037037037037, 'Slovakia'],
 ['riga', 0.7037037037037037, 'Latvia'],
 ['bilbao', 0.7037037037037037, 'Spain'],
 ['mikonos', 0.5925925925925926, 'Greece'],
 ['santander', 0.5925925925925926, 'Spain'],
 ['dubrovnik', 0.5555555555555556, 'Croatia'],
 ['fuerteventura', 0.5555555555555556, 'Spain'],
 ['santiago-de-compostela', 0.5555555555555556, 'Spain'],
 ['mahon', 0.5185185185185185, 'United States'],
 ['asturias', 0.48148148148148145, 'Spain'],
 ['granada', 0.4074074074074074, 'Spain'],
 ['almeria', 0.37037037037037035, 'Spain'],
 ['tenerife', 0.3333333333333333, 'Spain'],
 ['santa-cruz-de-la-palma', 0.2962962962962963, 'Spain'],
 ['murcia', 0.2962962962962963, 'Spain'],
 ['vigo', 0.2962962962962963, 'Spain'],
 ['zaragoza', 0.2962962962962963, 'Spain'],
 ['jerez', 0.25925925925925924, 'Spain']]

df_normalized_city_score = pd.DataFrame(normalized_city_score,columns=["city","score", "country"])

# Función que coge json y lo convierte en list of lists
def add_to_table(result):
  price_matrix = []
  # Le metemos cada valor
  for r in range(len(result["data"])):
    price_row = []
    price_row.append(result["data"][r]["route"][0]["cityFrom"])
    price_row.append(result["data"][r]["route"][0]["cityTo"])
    price_row.append(result["data"][r]["route"][0]["mapIdto"])
    price_row.append(datetime.datetime.fromtimestamp(int(result["data"][r]["route"][0]["aTimeUTC"])).strftime('%H:%M:%S'))
    price_row.append(datetime.datetime.fromtimestamp(int(result["data"][r]["route"][0]["aTimeUTC"])).strftime('%Y-%m-%d'))
    price_row.append(result["data"][r]["price"])
    price_row.append(result["data"][r]["route"][0]["id"])
    price_matrix.append(price_row)
  return price_matrix

# le metes origen, destinos y fecha y te da el list of lists
def precioTrayectos(origen, destinos, fecha, pasajeros):
  # si input es una lista al convertir a string tenemos que quitar los corchetes [ ]
  destinos = str(destinos).replace("'", "").replace(" ", "").replace("[", "").replace("]", "")
  #print("Get prices from {} to {} on {}".format(origen, destinos, fecha))
  if len(destinos) == 0:
    destinos = ""
  if not pasajeros:
    pasajeros = 1
  params = {
            "partner":"picky",
            "locale":"es",
            "curr":"EUR",
            "dateFrom": fecha,
            "dateTo": fecha,
            "directFlights": 1,
            "oneforcity": 1,
            "passengers": pasajeros,
            "flyFrom": origen,
            "to": destinos,
            "limit": 20            
  }
  host = "https://api.skypicker.com/flights"
  resp_code = 0
  req_attempts = 0
  while resp_code != 200:
    response = requests.get(host, params = params)
    resp_code = response.status_code
    req_attempts += 1
    if resp_code != 200:
      print('Response code of attempt {} is: {}'.format(req_attempts, resp_code))
  full_matrix = add_to_table(response.json())
  return full_matrix


# Función que suma días
def addDays(fecha,days):
  fecha = datetime.datetime.strptime(fecha, "%d/%m/%Y")
  fecha2 = fecha + datetime.timedelta(days=int(days))
  return datetime.datetime.strftime(fecha2, "%d/%m/%Y")


# Class que usaremos luego para pasar a json
class MyEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, np.integer):
            return int(obj)
        elif isinstance(obj, np.floating):
            return float(obj)
        elif isinstance(obj, np.ndarray):
            return obj.tolist()
        else:
            return super(MyEncoder, self).default(obj)


# Convertir todos los vuelos del DF de una combinación a una única fila
def compressFlightsToCombination(combinations_flights):
  #one_combination_flights = pd.DataFrame([],  columns = full_matrix.columns.values)
  compressed_combination = combinations_flights.loc[0].copy()
  string_columns = ["To", "Hour", "Date", "Id"]
  for column in string_columns:
    compressed_combination[column] = combinations_flights[column].tolist()
  compressed_combination["Id"] = str(compressed_combination["Id"])[1:-1].replace("'","").replace(", ","%7C")
  compressed_combination["Price"] = np.sum(combinations_flights['Price'].values)
  route_columns = ['From', 'To', 'Date', 'Hour', 'Price']
  compressed_combination["Route"] = (combinations_flights[route_columns].
                                     values.tolist())
  return compressed_combination


# Convertir un DF te combinaciones al formato diccionario
def convertCombinationDfToDict(combinations_df, passengers):
  combination_dict = {}
  for index, combination in combinations_df.iterrows():
    price_by_person = round(float(combination['Price'])/passengers,2)
    combination_dict["combination{}".format(index)] = {
        'passengers': passengers,
        'departure': combination['From'], 
        'destinations': combination['To'],
        'dates': combination['Date'],
        'price': price_by_person,
        'url': ("https://www.kiwi.com/deep?flightsId={}&price={}&passengers={}&affilid=picky&lang=es&currency=EUR".
                format(combination['Id'],combination['Price'],passengers)),
        'route': combination['Route']
    }
  return combination_dict

 
# Función para encontrar el mejor trayecto utilizando el algoritmo meta-heurístico
def findBestPathLocMulti(full_matrix, departure_cities, ciudades_deseadas, n_ciudades_a_visitar, fechas, pasajeros, n_combinaciones):
  n_viajes = n_ciudades_a_visitar + 1
  n_ciudades_a_elegir = len(ciudades_deseadas) #conjunto ciudades entre las que elegir
  
  # comprobar que sea posible elegir n combinaciones con tantas ciudades y tantos viajes
  possible_combinations = int(math.factorial(n_ciudades_a_elegir)/math.factorial(n_ciudades_a_elegir - n_ciudades_a_visitar))
  if (n_combinaciones > possible_combinations):
    # it is not posible to find all the combinations in these conditions
    print("Not possible to create {} combinations by choosing {} of {} desired cities! Only {} are possible"
                     .format(n_combinaciones, n_ciudades_a_visitar, n_ciudades_a_elegir, possible_combinations))
    n_combinaciones = possible_combinations
  
  # buscamos el mejor recorrido para cada una de las combinaciones
  print("Show {} combinations from all the {}: choose {} cities from {} choices ({} flights)"
        .format(n_combinaciones, possible_combinations, n_ciudades_a_visitar, n_ciudades_a_elegir, n_viajes))
  all_combinations_flights = pd.DataFrame([], columns =  np.append(full_matrix.columns.values, "Route"))
  all_paths = {}
  combination = 0
  comb_found = 0
  print("Departure and arrival unique cities: ", departure_cities)
  while (comb_found < n_combinaciones) and (combination < possible_combinations):
    print("*****************************************************************")
    one_combination_flights = pd.DataFrame([], columns = full_matrix.columns.values)
    visited_cities = departure_cities.copy()
    current_city = departure_cities.copy()

    # calcula el idx_viaje para el que habrá que hacer excepcion y no elegir el viaje mas barato para generar combinaciones
    flight_to_except = (combination - 1)%(n_ciudades_a_visitar)
    index_if_except = math.ceil(float(combination)/(n_ciudades_a_visitar))
    print('In combination {} we must choose the {} cheaper price for flight {}'
          .format(combination + 1, index_if_except + 1, flight_to_except + 1))

    # calcula los precios desde la ciudad actual hasta las siguientes
    discard_comb = False
    for idx_viaje in range(n_viajes):
      current_date = fechas[idx_viaje]
      print('Starting flight {}/{}: from {} on date {}'.format(idx_viaje + 1,n_viajes,current_city, current_date))
      
      # Mira si el viaje actual es el último o no
      if (idx_viaje + 1) < n_viajes:
        # Si no es el último viaje, además hay que evitar que el destino sea una ciudad ya visitada
        accepted_cities = [element not in visited_cities for element in full_matrix['To']]     
      else:
        # Si es el último viaje, destino tiene que ser un de las ciudades de origen
        accepted_cities = [element in departure_cities for element in full_matrix['To']]
      
      # Mirar destinos posibles teniendo en cuenta lo anterior, la fecha y la ciudad actual
      filas_viajes_posibles = ([element in current_city for element in full_matrix['From']] & 
                               (full_matrix['Date'] == current_date) & accepted_cities)
      
      # Saca el df con todos los posibles destinos encontrados
      n_viajes_posibles = np.sum(filas_viajes_posibles)
      if n_viajes_posibles > 0:
        viajes_posibles = full_matrix.loc[filas_viajes_posibles].sort_values('Price')
      else:
        viajes_posibles = pd.DataFrame([], columns = full_matrix.columns.values)
        discard_comb = True
        print("No flights found from {} on {}!".format(current_city, current_date))
      print("All the flights found:\n", viajes_posibles)
      
      # Decide si este vuelo es la excepción para generar varias combinaciones y mira si hay suficientes
      if idx_viaje == flight_to_except:
        # Comprueba que se hayan encontrado encontrado alternativas suficientes
        index_lower_price = index_if_except
        if (index_if_except >= n_viajes_posibles):
          discard_comb = True
          print("Not enough flights in combination {} from {} on {} to find another combination!"
                            .format(combination + 1, current_city, current_date))
      else:
        # No es la excepcion o es el vuelo de vuelta
        index_lower_price = 0
      print('Choosen flight {} of {} possible trips:\n {}'.
            format(index_lower_price + 1, n_viajes_posibles, viajes_posibles))

      # Actualiza los datos del mejor vuelo encontrado si la comb es valida
      if not discard_comb:
        one_combination_flights.loc[idx_viaje] = viajes_posibles.iloc[index_lower_price].copy()
        current_city = one_combination_flights['To'].loc[idx_viaje]
        visited_cities.append(current_city)
      else:
        print("Combination {} was discarded".format(combination + 1))
        break
      #print("visited cities: ", visited_cities)
    # comprime la info de todos los vuelos de la combinación encontrada en una única fila
    print("For combination {} there are the following flights:\n{}".format(combination+1, one_combination_flights))
    if not discard_comb:
      all_combinations_flights.loc[comb_found] = compressFlightsToCombination(one_combination_flights)
      comb_found += 1
      print("For combination {} there are the following flights:\n{}".format(comb_found, one_combination_flights))
    combination += 1
  all_combinations_flights.drop('CodeTo', axis=1, inplace=True)
  all_combinations_flights.sort_values(["Price"], inplace=True)
  #print("All the combinations found are:\n", all_combinations_flights)
  all_paths = convertCombinationDfToDict(all_combinations_flights, pasajeros)
  #print("All combinations converted to df:\n", 
  #      convertCombinationDfToDict(all_combinations_flights, pasajeros))
  return all_combinations_flights

# Función equivalente a fullMatrix pero sin destinos fijos

def fullMatrixNoDestinos(origen, df_normalized_city_score, fecha_salida, dias_por_ciudad, numero_ciudades, pasajeros):
  # df_normalized_city_score es un df, convertimos la primera columna a list para tenerlo más manejable
  cool_connections = df_normalized_city_score["city"].tolist()
  
  full_matrix = pd.DataFrame(columns=["From","To","CodeTo","Hour","Date","Price","Id","Score"])
  # Ida
  # Creamos una lista, dentro de ella pondremos más listas con los destinos para que hagan de orígenes en la siguiente iteración
  origins = []
  # Buscamos los 20 vuelos más baratos desde el origen y convertimos el resultado a df
  precios_ida = precioTrayectos(origen,"",fecha_salida, pasajeros)
  df_precios_ida = pd.DataFrame(precios_ida,columns=["From","To","CodeTo","Hour","Date","Price","Id"])
  # Sacamos el precio del vuelo más caro
  precio_max = df_precios_ida.loc[df_precios_ida['Price'].idxmax()]["Price"]
  # Filtramos solo los vuelos que acaban en un destino de cool_connections
  filtered_df = df_precios_ida[df_precios_ida["CodeTo"].isin(cool_connections)]
  # Añadimos al df una columna con el score de cada ciudad y ordenamos
  filtered_df.loc[:,"Score"] = 1 - (filtered_df.loc[:,"Price"] / precio_max)
  filtered_df.sort_values("Score",ascending = False)
  # Cogemos los cinco destinos con mayor score y los añadimos a origins para la siguiente iteración
  origins.append(filtered_df.loc[:4,"CodeTo"].tolist())
  # Y guardamos toda la info de los tres viajes en el df full_matrix
  full_matrix = full_matrix.append(filtered_df.loc[:2])

  # Trayectos intermedios
  # Loopeamos en función del número de ciudades que el user quiere ver -1
  for c in range(numero_ciudades - 1):
    # Sumamos días a la fecha de salida
    fecha_salida = addDays(fecha_salida, dias_por_ciudad)
    origins.append([])
    # Buscamos vuelos desde cada uno de los destinos de la fecha anterior
    for o in origins[-2]:
      # print("estamos buscando vuelos desde " + d + "el día " + str(c))
      # Sacamos precios y convertimos a df
      precios_ida = precioTrayectos(o,"",fecha_salida, pasajeros)
      df_precios_ida = pd.DataFrame(precios_ida,columns=["From","To","CodeTo","Hour","Date","Price","Id"])
      #print(df_precios_ida)
      # Sacamos el precio del vuelo más caro
      precio_max = df_precios_ida.loc[df_precios_ida['Price'].idxmax()]["Price"]
      # Filtramos solo los vuelos que acaban en un destino de cool_connections
      filtered_df = df_precios_ida[df_precios_ida["CodeTo"].isin(cool_connections)]
      # Añadimos al df una columna con el score de cada ciudad y ordenamos
      filtered_df.loc[:,"Score"] = 1 - (filtered_df.loc[:,"Price"] / precio_max)
      filtered_df.sort_values("Score",ascending = False)
      # Cogemos los cinco destinos con mayor score y si no están ya, los añadimos a origins para la siguiente iteración
      new_origins = filtered_df.loc[:4,"CodeTo"].tolist()
      for x in new_origins:
        if x not in origins[-1]:
          origins[-1].append(x)
      # print(origins)          
      # Y guardamos toda la info de los tres viajes en el df full_matrix
      full_matrix = full_matrix.append(filtered_df.loc[:2]) 
      full_matrix
              
  # Vuelta
  fecha_salida = addDays(fecha_salida, dias_por_ciudad)
  for o in origins[-1]:
    precio_vuelta = precioTrayectos(o, origen, fecha_salida, pasajeros)
    df_precio_vuelta = pd.DataFrame(precio_vuelta,columns=["From","To","CodeTo","Hour","Date","Price","Id"])
    df_precio_vuelta["Score"] = 1
    # Los añadimos todos al full_matrix
    full_matrix = full_matrix.append(df_precio_vuelta)

  return full_matrix


def fullMatrixConDestinos(origen, destinos, fecha_salida,dias_por_ciudad, numero_ciudades, pasajeros):
  # De origen a cada destino
  first_flight_options = precioTrayectos(origen, destinos, fecha_salida, pasajeros)
  #print('first_flight_options:\n', first_flight_options)

  # Loop que busca todas las combinaciones entre destinos
  in_between_flights_options = []
  for i in range(numero_ciudades - 1):
    fecha_salida = addDays(fecha_salida,dias_por_ciudad)
    for departure_city in destinos:
      other_cities = [city for city in destinos if city != departure_city]
      
      flights_current_city = precioTrayectos(departure_city, other_cities, fecha_salida, pasajeros)
      in_between_flights_options += flights_current_city
      #print('Starting from {}, checking destinations: {}.\n'.format(departure_city, other_cities), flights_current_city)

  # Loop que busca los viajes de vuelta
  fecha_salida = addDays(fecha_salida,dias_por_ciudad)
  last_flight_options = []
  for d in destinos:
    last_flight_options += precioTrayectos(d, origen, fecha_salida, pasajeros) 
    #print('last_flight_options from {} to {} on {}:\n'.format(d, origen, fecha_salida), [element[1] for element in last_flight_options])

  # Convertimos los tres trozos en Series y los metemos en un dataframe
  columnas = pd.Series(["From", "To", "CodeTo", "Hour", "Date", "Price", "Id"])
  final_matrix1 = pd.DataFrame(first_flight_options, columns=columnas)
  final_matrix2 = pd.DataFrame(in_between_flights_options, columns=columnas)
  final_matrix3 = pd.DataFrame(last_flight_options, columns=columnas)

  full_matrix = pd.concat([final_matrix1, final_matrix2, final_matrix3])
  #print(full_matrix.loc[:, full_matrix.columns != 'Id'])
  return full_matrix

result = precioTrayectos("BCN", "MAD", "11/08/2018", 1) 
result

# Inputs: origen, destinos, fecha_salida días por ciudad
def fullMatrix(origen, destinos, fecha_salida,dias_por_ciudad, numero_ciudades, pasajeros, n_combinaciones):
  #print("Get the prices from {} to {}. {} days per city, {} cities to visit, {} passengers"
  #     .format(origen, destinos, dias_por_ciudad, numero_ciudades, pasajeros))
  
  # Comprobamos si origen es string y que no haya más de 9 destinos
  if not isinstance(origen, str):
    raise ValueError("Error! Origen must be string")
  elif (len(destinos) > 9) or (numero_ciudades > 9):
    raise ValueError("Error! Not more than 9 destinos")

  # Si destinos está vacío, tiramos de fullMatrixNoDestinos
  if len(destinos) == 0:
    print("No hay destinos, se sacan con fullMatrixNoDestinos")
    full_matrix = fullMatrixNoDestinos(origen, df_normalized_city_score, fecha_salida, dias_por_ciudad, numero_ciudades, pasajeros)
  # Si no, seguimos con la fullMatrixConDestinos
  else:
    print("Los destinos son:", destinos)
    full_matrix = fullMatrixConDestinos(origen, destinos, fecha_salida,dias_por_ciudad, numero_ciudades, pasajeros)
  full_matrix.sort_values(["Date","Price"])
  return full_matrix #final_json

origen = "madrid"
destinos_posibles = ['BCN', 'PAR', 'LON', 'BER']
fecha = "11/08/2018"
dias_por_ciudad = 2
numero_ciudades = 3
pasajeros = 1
combinaciones = 5
full_matrix = fullMatrix(origen, destinos_posibles, fecha, dias_por_ciudad, numero_ciudades, pasajeros, combinaciones)

full_matrix

origen = "madrid"
destinos_posibles = []
fecha = "11/08/2018"
dias_por_ciudad = 2
numero_ciudades = 3
pasajeros = 1
combinaciones = 5
full_matrix = fullMatrix(origen, destinos_posibles, fecha, dias_por_ciudad, numero_ciudades, pasajeros, combinaciones)

full_matrix

def getMatrixAndCombinations (origen, destinos, fecha_salida, dias_por_ciudad, numero_ciudades, pasajeros, n_combinaciones):
  """
  Esta funcion tiene como entrada los inputs del usuario. Crea la matriz de vuelos usando fullMatrix, saca los inputs necesarios
  para llamar a "findbestpathloc", y del df de combinacioneshace el return del json.
  """
  # Sacamos el DF con la info de todos los vuelos necesarios
  full_matrix = fullMatrix(origen, destinos, fecha_salida,dias_por_ciudad, numero_ciudades, pasajeros, n_combinaciones)
  print("La matriz de vuelos queda:\n", full_matrix.loc[:, full_matrix.columns != 'Id'])
  
  # Sacamos origen, destinos, fechas y número de ciudades
  fechas = sorted(full_matrix["Date"].unique().tolist())
  print("fechas:", fechas)
  origen = list(full_matrix.loc[(full_matrix["Date"] == fechas[0]), "From"].unique())
  print("origen:", origen)
  ciudades_vuelta = list(full_matrix.loc[(full_matrix["Date"] == fechas[-1]), "To"].unique())
  print("ciudades vuelta:", ciudades_vuelta)
  origen.extend(city for city in ciudades_vuelta if city not in origen)
  print("ciudades origen/vuelta", ciudades_vuelta)
  destinos = [city for city in full_matrix["To"].unique() if city != origen]
  full_matrix['Price'] = full_matrix['Price'].apply(pd.to_numeric)
  
  # De todos los vuelos encontramos las mejores combinaciones
  best_combinations_df = findBestPathLocMulti(full_matrix, origen, destinos, numero_ciudades, fechas, pasajeros, n_combinaciones)
  # Convertimos a diccionario
  #best_combinations_dict = convertCombinationDfToDict(all_combinations_flights, pasajeros))
  # Convertimos a json
  #best_combinations_json = json.dumps(best_combinations_dict, cls=MyEncoder)
  
  return best_combinations_df


if __name__ == "__main__":
    origen = "madrid"
    destinos_posibles = ['BCN', 'PAR', 'LON', 'BER']
    fecha = "11/08/2018"
    dias_por_ciudad = 2
    numero_ciudades = 3
    pasajeros = 2
    combinaciones = 5
    combinations_df = getMatrixAndCombinations (origen, destinos_posibles, fecha, dias_por_ciudad, numero_ciudades, pasajeros, combinaciones)
    combinations_df
    
    origen = "madrid"
    destinos_posibles = []
    fecha = "11/08/2018"
    dias_por_ciudad = 2
    numero_ciudades = 3
    pasajeros = 2
    combinaciones = 5
    combinations_df = getMatrixAndCombinations (origen, destinos_posibles, fecha, dias_por_ciudad, numero_ciudades, pasajeros, combinaciones)
    combinations_df
    
    test_full_matrix = fullMatrixNoDestinos("madrid", df_normalized_city_score, "11/08/2018", 2, 3, 2)

    test_full_matrix

origen = "BCN"
destinos_posibles = ["DUB", "VIE", "ATH","TLS"]
fecha = "15/07/2018"
dias_por_ciudad = 2
ciudades_minimas_visitar = 3
pasajeros = 1
combinaciones = 10
full_matrix = fullMatrix(origen, destinos_posibles, fecha, dias_por_ciudad, ciudades_minimas_visitar, pasajeros, combinaciones)
full_matrix
solucion="""
2  Barcelona  [Atenas, Toulouse, Dublín, Barcelona]   
0  Barcelona   [Toulouse, Atenas, Viena, Barcelona]   
3  Barcelona     [Dublín, Viena, Atenas, Barcelona]   
1  Barcelona  [Toulouse, Atenas, Dublín, Barcelona]   
"""

origen = "BCN"
destinos_posibles = ["LPL","DUB", "VIE", "ATH","TLS", "MPL"]
fecha = "15/08/2018"
dias_por_ciudad = 2
ciudades_minimas_visitar = 3
pasajeros = 1
combinaciones = 10
full_matrix = fullMatrix(origen, destinos_posibles, fecha, dias_por_ciudad, ciudades_minimas_visitar, pasajeros, combinaciones)
full_matrix
solucion="""
1  Barcelona  [Liverpool, Dublín, Toulouse, Barcelona]   
4  Barcelona     [Viena, Dublín, Liverpool, Barcelona]   
0  Barcelona    [Liverpool, Dublín, Atenas, Barcelona]   
3  Barcelona     [Liverpool, Dublín, Viena, Barcelona]   
2  Barcelona        [Atenas, Viena, Dublín, Barcelona]   
"""

origen = "BCN"
destinos_posibles = ["BUD","OTP", "SOF", "PRG", "ATH", "KRK", "WAW", "DBK", "BTS"]
fecha = "15/08/2018"
dias_por_ciudad = 3
ciudades_minimas_visitar = 3
pasajeros = 1
combinaciones = 4
full_matrix = fullMatrix(origen, destinos_posibles, fecha, dias_por_ciudad, ciudades_minimas_visitar, pasajeros, combinaciones)
full_matrix
solucion= """
1  Barcelona  [Praga, Varsovia, Bratislava, Gerona]   
2  Barcelona    [Sofía, Budapest, Praga, Barcelona]   
0  Barcelona   [Sofía, Atenas, Bucarest, Barcelona]   
3  Barcelona   [Sofía, Atenas, Budapest, Barcelona]
"""

origen = "BCN"
destinos_posibles = ["BUD","OTP", "SOF", "ATH", "KRK", "WAW", "DBK", "BTS"]
fecha = "15/08/2018"
dias_por_ciudad = 3
ciudades_minimas_visitar = 3
pasajeros = 1
combinaciones = 10
full_matrix = fullMatrix(origen, destinos_posibles, fecha, dias_por_ciudad, ciudades_minimas_visitar, pasajeros, combinaciones)
full_matrix
solucion="""
2  Barcelona     [Sofía, Budapest, Varsovia, Barcelona]   
0  Barcelona       [Sofía, Atenas, Bucarest, Barcelona]   
3  Barcelona       [Sofía, Atenas, Budapest, Barcelona]   
6  Barcelona        [Sofía, Atenas, Bratislava, Gerona]   
8  Barcelona       [Sofía, Atenas, Varsovia, Barcelona]   
4  Barcelona       [Budapest, Sofía, Atenas, Barcelona]   
1  Barcelona  [Varsovia, Bratislava, Atenas, Barcelona]   
7  Barcelona       [Atenas, Sofía, Budapest, Barcelona]   
9  Barcelona       [Bucarest, Atenas, Sofía, Barcelona]   
5  Barcelona      [Sofía, Varsovia, Bratislava, Gerona]   
"""

full_matrix

d = json.loads(full_matrix)
d
